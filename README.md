# [Ultimate Rust 2: Intermediate Concepts (Udemy Course)](https://www.udemy.com/course/ultimate-rust-2/)

This repository contains the code examples and exercises for the Udemy course "Ultimate Rust 2: Intermediate Concepts". The course is designed to help you deepen your understanding of Rust programming and its advanced features.

---

## Idiomatic Rust

---

_Idiomatic:_ Expressions that are natural to a native speaker of a language. In programming, idiomatic code is code that is written in a way that is natural and expected by other programmers familiar with the language.

### There are two tools developed by community members that help you write idiomatic Rust code

- _rustfmt_ - A tool that formats Rust code according to style guidelines. It can be run manually using `cargo fmt` or automatically on save in your editor.
- _clippy_ - A linter that provides suggestions for improving your Rust code. It can be run manually using `cargo clippy` or automatically on save in your editor.

### More about `clippy`

Running `cargo clippy` compiles your code and checks for over 450 specific problems, patterns that are considered non-idiomatic or could be improved. It provides suggestions for better practices, such as using `if let` instead of `match` when you only care about one pattern, or using `?` for error handling instead of `unwrap()`.

Generally, the problem can be categorized into 4 categories:

- **Style**: Issues related to code formatting and style conventions. If there is more idiomatic way to write the code, clippy will suggest it.

- **Correctness**: Issues that may lead to bugs or unexpected behavior. Clippy will warn you about potential mistakes in your code. It will also warn you about codes that may lead to undefined behavior or are completely unnecessary.

- **Complexity**: Issues that indicate the code is too complex or hard to read. Clippy will suggest ways to simplify your code, making it more maintainable and understandable. These warning comes into two flavors:

  One where clippy knows for sure that the code is too complex, and one where it is just a suggestion that the code could be simplified.

- **Performance**: Issues that may lead to inefficient code. Clippy will suggest ways to improve the performance of your code, such as using more efficient data structures or algorithms.

You can google `clippy lints` to find the full list of lints that clippy checks for.

## Attributes

Attributes in Rust are metadata applied to some module, crate, or item. They can be used to control the behavior of the compiler or to provide additional information about the code.

They start with a `#` symbol and can be applied to various items in Rust, such as functions, structs, enums, and modules. Attributes can be used to enable or disable certain features, provide documentation, or control the visibility of items.
e.g. `#[allow(dead_code)]` is an attribute that tells the compiler to allow dead code, which is code that is never used or called. It is also called outer attribute, because it is applied just before the item it applies to.

## Documentation

Documentation in Rust is written using comments and attributes. The most common way to write documentation is to use `///` comments, which are called doc comments. They are used to document items such as functions, structs, enums, and modules.

Cargo can be used to generate documentation for your Rust code using the `cargo doc` command. This command generates HTML documentation from the doc comments in your code and places it in the `target/doc` directory.
But usually people use `cargo doc --no-deps --open` to generate documentation. This command generates documentation for your code without including dependencies and opens it in your default web browser.

Let's if you want to document `pub const PUZZLE_PIECES: u32 = 42;`. This will be automatically included in the documentation generated by `cargo doc`. You can document private items as well, but they will not be included in the generated documentation.

```rust
/// Number of puzzle pieces in the game.
pub const PUZZLE_PIECES: u32 = 42;
```

You can also use `//!` comments to write documentation for a module or crate. These comments are called inner attributes and are used to document the entire module or crate. They are placed at the top of the file, before any items.

```rust
//! This module contains the game logic for the puzzle game.
//! It includes functions for creating puzzles, checking solutions, and scoring.
```

Only the first paragraph of the doc comment will be used as the summary in the generated documentation. The rest of the comment will be used as the description. Clicking on the item in the generated documentation will show the full doc comment, including the summary and description.

Doc comments use common mark Markdown syntax, so you can use formatting such as headings, lists, and code blocks. You can also use links to other items in your code using the `[` and `]` syntax.

```rust
/// Number of pieces in the puzzle
///
/// # History
///
/// This is a separate paragraph.
/// - Clickable link: [`PUZZLE_PIECES`]
/// - We tried `7`, but this is better
pub const PUZZLE_PIECES: u32 = 42;
```

You can also use `#[doc]` attributes to write documentation for items. This is useful when you want to write documentation for an item that is not a function, struct, enum, or module. For example, you can use it to document a constant or a type alias.

Rust documentation should always start with a simple description/summary of what the item does. It should be concise and to the point. The first sentence should be a summary of the item, and the rest of the comment can provide additional information, such as examples or usage instructions. They can include headers, lists, and code blocks, just like doc comments.

One thing to note is about **intradoc links**. They are used to link to other items in your code. They are written using the `[` and `]` syntax. But they must be in the scope. But if it is not in scope, then you can use the absolute path.

There is also inner documentation comment. You can use it by using `//!`. This can be used for module libraries.

```rust
//! Hi! I'm your friendly Rust Puzzle Library documentation. Please come in, sit down, and have a
//! cup of hot chocolate.

```

For a struct, documentation can be written something like this. You usually add comments above all associated functions. You can also add documentation to a struct fields.

```rust
/// This is a Puzzle
pub struct Puzzle {
    /// Number of pieces
    pub num_pieces: u32,
    /// Descriptive Names
    pub name: String,
}

impl Puzzle {
    /// Make a new puzzle!
    pub fn new() -> Self {
        Self {
            num_pieces: PUZZLE_PIECES,
            name: "Forest Lake".into(),
        }
    }
}
```

### To document private items you can use `--document-private-items` flag

## Publishing

You can publish your crate to `crates.io`, rust communities, package registry. **Note that anything you publish will be permanent.** Package names need to be unique, at least as of today on 27-July-2025.

### Steps to publish to your package

- **Step 1:** Login to crates.io via GitHub.
- **Step 2:** In account settings, API Access, generate new token using `New Token` button.
- **Step 3:** Then you run `cargo login` and pass your generated token. This will take care of authentication process.
- **Step 4:** Configure your project/library for publishing

  ### Strongly Recommended Settings Before Publishing

  ```toml
  [package]
  name = "rusty_engine"
  version = "2.0.0"
  description = "Some Description"
  edition = "2024"
  homepage = "<usually link to your website for the project, you can also use github repo>"
  repository = "https://github.com/CleanCut/rusty_engine"
  readme = "README.md"
  keywords = ["game", "engine", "graphics", "audio", "rusty"]
  categories = ["game-engine"]
  license = "MIT OR Apache-2.0"
  ```

  Publishing can be done with only 2 of the attributes, `name` and `version`

  - `keywords` 5 words/tags which can be used to improve ranking on crates.io
  - `categories` Up to 5 applicable categories from the `All valid Category Slugs` page on crates.io

- **Step 5:** - Then `cargo publish` can be used to publish. It will do compile checks, build docs, check versions if nothing conflicts, it will publish. It will also publish documentation on docs.rs.
